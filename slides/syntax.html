---
layout: slides
title: Intro
---
<section>
	<h1>Syntax and Control Structures</h1>
	<footer>Intro to Python</footer>
</section>

<section>
<h2>Overview</h2>
<ul>
	<li>The Python interpreter</li>
	<li>Syntax</li>
	<li>Control structures</li>
	<li>Data types</li>
</ul>
<details>
</details>
</section>

<section>
<h2>The Python interpreter</h2>
<ul>
	<li>Running programs</li>
	<li>Interactive shell</li>
	<li>Some mild introspection</li>
	<li>Everything is an object!</li>
</ul>
<details>
</details>
</section>

<section>
<h2>Running programs</h2>
<ul>
	<li>Use the interpreter followed by the filename of your program</li>
	<li>The extension of the filename can be anything, but .py is the convention</li>
</ul>
{% highlight console %}
walsh:tmp joe$ echo "print 'Hi PyGotham'" > hello.py
walsh:tmp joe$ python hello.py 
Hi PyGotham
{% endhighlight %}
<details>
<ul>
	<li>Can pass flags... for example --help shows help, -c runs a command</li>
	<li>python -c 'print "hello"'</li>
</ul>
</details>
</section>

<section>
<h2>Interactive shell</h2>
<ul>
	<li>Without the filename, the interactive shell is started</li>
	<li>Executes input line-by-line</li>
</ul>
{% highlight pycon %}
>>> # prompts for an expression or statement
... # prompts that an expression or statement needs more input
{% endhighlight %}
<ul>
	<li>&lt;Enter&gt; after a prompt for more input ends that expression or statement</li>
	<li>Values returned from expressions are printed out</li>
	<li>Instant feedback is great for testing, debugging and experimenting</li>
</ul>
<details>
<ul>
<pre>
5 + 3
import sys
if True:
	print "I don't believe it!"
if True: # waiting for input shows an error
...
# show what "asdf" vs "" resolves to in if statement
</pre>
</details>
</section>

<section>
<h2>Some mild introspection... and others</h2>
<ul>
	<li>help</li>
	<li>dir</li>
	<li>type</li>
	<li>import</li>
	<li>print</li>
</ul>
<details>
<pre>
help() # no params gives you interactive help.  "quit" or ^D to quit.
keywords, ^D
help([1, 2, 3]), import sys, help(sys) #... by the way, brackets denotes a list!
import sys, dir(sys), dir(""), dir([]) # import brings in a module... (which is just a file with code)
type(sys), type(5), li = [], type(li), dir(li), type(li.append),
 help(li.append), li, li.append('foo'), li
</pre>
</details>
</section>

<section>
<h2>Syntax</h2>
<ul>
	<li>Basic syntax</li>
	<li>Dot notation, functions/methods and attributes</li>
	<li>Expressions and simple assignment</li>
	<li>Space! Object spaces, namespaces</li>
	<li>Assignment / binding?</li>
</ul>
<details>
</details>
</section>

<section>
<h2>Basic syntax</h2>
<ul>
	<li>White space significant</li>
	<li>Colon and indentation signify code blocks</li>
	<li>Each line is a single statement</li>
</ul>
<details>
<ul>
	<li>Leading whitespace is meaningful to the program structure!<li>
	<li>You can use tabs or spaces, but not both.  The convention is to use 4 spaces, though any number is possible as long as it's consistent (demo if with one space, then two).  I use tabs, which is bad.</li>
	<li>blocks, or groups of statements are specified by indentation level.</li>
	<li>lines separate statements, unless you explicitly create a continuation using a backslash, but must indent next (demo).</li>
	<li>or """ quoted string, or an unbalanced brace, bracket, parens (demo).</li>
</ul>
</details>
</section>

<section>
<h2>Dot notation, functions/methods and attributes</h2>
<ul>
	<li>Dots are used for accessing both functions/methods and attributes</li>
	<li>Functions and methods are invoked with parentheses; they're "callables"</li>
	<li>Attributes can be accessed and assigned</li>
</ul>
<details>
<ul>
	<li>You'll see that they're both actually the same... functions/methods are just callable attributes.  use [].append</li>
	<li>Demo callable keyword (foo = 12, def bar(): pass, callable)</li>
</ul>
<pre>
>>> class Foo:
...  def __init__(self):
...   self.bar = 12
</pre>
</details>
</section>


<section>
<h2>Expressions and simple assignment</h2>
<ul>
	<li>Arithmetic operations</li>
	<li>Assignment</li>
	<li>Multiple and consecutive assignment</li>
	<li>Undefined variables</li>
</ul>
<details>
<ul>
	<li>(demo)+ - *  / all work as you'd expect.  whitespace separating tokens is not significant.</li>
	<li>(demo) also % (modulo), 5**2 for exponents</li>
	<li>(demo) operations on two integers yield integers 5 / 2</li>
	<li>(demo) use = to assign variables</li>
	<li>(demo) a = b = c = 2</li>
	<li>(demo) (a, b, c) = (1, 2, 3) ... these are actually tuples, we'll talk about these later</li>
	<li>(demo) use undefined u + 2 throws NameError</li>
</ul>
</details>
</section>

<section>

<h2>Space! Object spaces, namespaces</h2>
<ul>
	<li>Distinction between names (variable names) and values (1, "foo", [23, 35])</li>
	<li>Namespace - holds names</li>
	<li>Object space - holds values</li>
	<li>Names reference values</li>
	<li>Unreferenced values "disappeaer" after use; referenced values persist as variables</li>
</ul>
{% highlight python %}
a = "A string"
b = ["a", "list", "of", "strings"]
"a " + "b " + "c"
{% endhighlight %}
<details>
</details>
</section>

<section>
<h2>Which looks like...</h2>
{% highlight python %}
"""
namespace         object space
----------         -------------
a   ----------->   "A string"

b   ----------->   ["a", ...."strings"]

                   "a " + "b " + "c" ---> not referenced! 


"""
{% endhighlight %}
<details>
<ul>
	<li>no ref... reclaim space with gc</li>
</ul>
</details>
</section>

<section>
<h2>And that matters... why? (<s>assignment</s> binding)</h2>
<ul>
	<li>Again, names are references to values; any name can refer to any value</li>
	<li>Assignment <b>copies references, not values</b> (hence binding)!</li>
	<li>The value determines the type, not the name</li>
	<li>Function parameters are passed as references</li>
	<li>Immutable objects look like they're dealt with by value, but they're not!  A new instance is created behind the scenes</li>
</ul>
<details>
<ul>
	<li>Legal names consist of letters, numbers and underscores (though numbers can't be first)</li>
	<li>(unlike java or c where the variable name is typed)</li>
	<li>pointer diagrams</li>
	<li>(demo) ? a = [1,2,3], a.append() ..... eventually b = a... ask about what b will be</li>
</ul>
</details>
</section>

<section>
<h2>Queue crude ASCII art</h2>
{% highlight python %}
a = [1, 2, 3]
b = a
"""
a -------->[1, 2, 3]
             ^
b -----------|
"""


a = [1, 2, 3]
b = [1, 2, 3]
"""
a --->[1, 2, 3]
b --->[1, 2, 3]
"""
{% endhighlight %}
<details>
<ul>
	<li>no ref... reclaim space with gc</li>
</ul>
</details>
</section>

<section>
<h2>Control structures</h2>
<ul>
	<li>Conditionals</li>
	<li>Loops</li>
	<li>Exceptions</li>
</ul>
<details>
</details>
</section>

<section>
<h2>Conditionals</h2>
{% highlight pycon %}
>>> animal = "duck"
>>> if animal == "cat":
...  print "meow"
... elif animal == "duck":
...  print "quack"
... else:
...  print "are you sure it's not a mineral?"
{% endhighlight %}
<ul>
	<li>elif and else are optional; there can be arbitrary number of elifs</li>
	<li>No switch-case!  Use many elif's</li>

</ul>
<details>
<ul>
	<li>Note the colon and indentation to denote blocks</li>
	<li>elif!?</li>
	<li>yes, it prints quack</li>
</ul>
</details>
</section>

<section>
<h2>Loops</h2>
<ul>	
	<li>For loops iterate over items in a sequence (such as lists or chars in a string)</li>
	<li>Not for arithmetic loop progression (well, maybe with some prodding)</li>
</ul>
{% highlight pycon %}
>>> for i in [-1, 1, 1, 5]:
...  print i + 2
{% endhighlight %}

{% highlight pycon %}
>>> for k, v in {'name':'doughnut', 
...  'flavor':'frosted with sprinkles'}.items():
...  print "key = " + k + ", value = " + v
{% endhighlight %}
<ul>
	<li>Just like every other while loop</li>
</ul>
{% highlight pycon %}
>>> while(True):
...  print 'too.  many.  sprinkles.'
{% endhighlight %}
<details>
<ul>
	<li>you can do multiple assignments for iterating over dictionaries</li>
	<li>using range(len(li)) is one way to to iterate over indeces</li>
	<li>? what's it print; yes, it prints quack</li>
	<li>? what's the output of other for loop</li>
	<li>? what's the output of while loop</li>
</ul>
</details>
</section>

<section>
<h2>Loopier</h2>
<ul>	
	<li>Pass, break, and continue</li>
</ul>
{% highlight pycon %}
>>> for i in range(5):
...  pass 
{% endhighlight %}
<ul>
	<li>else in a loop? only executes after loop terminates normally</li>
</ul>
{% highlight pycon %}
>>> for i in range(5):
...  print i
... else:
...  print "done"
{% endhighlight %}
<details>
(demo) Pass doesn't do anything at all (use for loop)
(demo) break and continue if necessary
</details>
</section>

<section>
<h2>Loopiest</h2>
<ul>	
	<li>A closer look (we're getting ahead of ourselves)</li>
</ul>
{% highlight pycon %}
>>> {'foo':'bar', 'baz':'qux'}.items()
[('foo', 'bar'), ('baz', 'qux')]

>>> for a, b, c in [(1, 2, 3),(4, 5, 6),(7, 8, 9)]:
...  print str(a) + ", " + str(b) + ", " + str(c)
... 
1, 2, 3
4, 5, 6
7, 8, 9
{% endhighlight %}
<details>
(demo) mentioned items... what does that do?  dictionary to list of tuples
</details>
</section>

<section>
<h2>Exceptions</h2>
<ul>	
	<li>Try-catch (with an IndexError)</li>
</ul>
{% highlight pycon %}
>>> li = [1, 2]
>>> try:
...  print li[42]
... except Exception, e:
...  print 'Oh noez ' + str(e)
... 
Oh noez list index out of range
{% endhighlight %}
<ul>	
	<li>Use raise to throw your own exception</li>
</ul>
{% highlight pycon %}
>>> raise Exception("Estoy enfermo")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
Exception: Estoy enfermo
>>> 
{% endhighlight %}
<details>
	<ul>
		<li>Catches specified exception(s), but Exception will catch all that are subclasses of it</li>
		<li>Optional finally keyword at end has block that will always execute</li>
		<li>Multiple excepts allowed for different code paths per exception type</li>
		<li>Use as to bind exceptions to name, can have multiple excepit blocks</li>
	</ul>
</details>
</section>

<section>
<h2>Catching 'em all (multiple exception types)</h2>
{% highlight pycon %}
>>> def raise_e(e):
...  try:
...   raise e
...  except (NameError, IndexError) as e:
...   print type(e)
... 
>>> raise_e(Exception)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in raise_e
Exception
{% endhighlight %}
<ul>	
</ul>
<details>
</details>
</section>

<section>
<h2>A brief detour</h2>
<ul>	
	<li>Remember what range() does?</li>
	<li>Remember how to iterate over a list?</li>
</ul>
<details>
<ul>	
	<li>range returns a list of integers</li>
	<li>iterate over a list with a for loop....</li>
	<li>(demo) list of integers</li>
	<li>(demo) iterating over list of integers</li>
</ul>
</details>
</section>

<section>
<h2>FizzBuzz</h2>
<p>
Print integers 1 to 100, but replace multiples of 3 with "Fizz" and multiples of 5 with "Buzz" and multiples of both with "FizzBuzz"
</p>
{% highlight console %}
joe@walsh~/projects/archived/fizzbuzz$ python fizzbuzz.py 
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
{% endhighlight %}
<details>
<ul>	
	<li></li>
</ul>
</details>
</section>

<section>
<h2>More fizz</h2>
<ul>
<li>It's a silly interview and code golf question from CodingHorror and http://golf.shinh.org/p.rb?FizzBuzz </li>
<li>Your output should look the same as the previous slide.</li>
</ul>
<details>
</details>
</section>

<section>
<h2>One way to do it:</h2>
{% highlight python %}
for n in range(1,100):
	if n % 3 == 0 and n % 5 == 0:
		print "fizzbuzz"
	elif n % 3 == 0:
		print "fizz"
	elif n % 5 == 0:
		print "buzz"
	else:
		print n
{% endhighlight %}
<details>
<ul>
	<li>Remember, no case statement!</li>
</ul>
</details>
</section>

<section>
<h2>Data types</h2>
<ul>
	<li>Mutability (and References)</li>
	<li>Numbers</li>
	<li>Booleans</li>
 	<li>Strings</li>
 	<li>None</li>
 	<li>Lists</li>
 	<li>Tuples</li>
 	<li>Dictionaries</li>
 	<li>Files</li>
</ul>
<details>
</details>
</section>

<section>
<h2>Accept the things you cannot change...</h2>
<p>Some types in Python are not mutable! (Remember, values have types).</p>
{% highlight pycon %}
>>> a
'foo'
>>> b
'foo'
>>> a + " bar"
'foo bar'
>>> a
'foo'
>>> b
'foo'
>>> a = a + " bar"
>>> a
'foo bar'
{% endhighlight %}
<p>Compare that to what happened with lists</p>
{% highlight pycon %}
>>> a = [1, 2, 3]
>>> b = a
>>> a
[1, 2, 3]
>>> b
[1, 2, 3]
>>> a.append(4)
>>> a
[1, 2, 3, 4]
>>> b # what will the value be?
{% endhighlight %}
<details>
</details>
</section>

<section>
<h2>Dictionaries</h2>
<ul>
<li>items()</li>
<li>key doesn't exist</li>
</ul>
<details>
</details>
</section>

<section>
<h2>Lists</h2>
<ul>
<li>copying a list: http://henry.precheur.org/python/copy_list</li>
<li>enumerate()</li>
<li>List Comprehensions</li>
<li>Copying lists</li>
<li>bounded</li>
</ul>
<details>
</details>
</section>

<section>
<h2>Conventions and Documentation</h2>
<p>
{% highlight pycon %}
And and or
>>> 'a' and 'b'         
'b'
>>> '' and 'b'          
''
>>> 'a' and 'b' and 'c' 
'c'
{% endhighlight %}
</p>
<p>
ternary operator
</p>
<details>
</details>
</section>

<section>
<h2>exercises</h2>
<ul>
	<li>fizzbuzz using range, foreach, if else</li>
	<li>sum #'s using foreach, then using arg, then maybe file io?, then file, then exception handling</li>
	<li>try using httplib and json for non reg twitter api http://api.twitter.com/1/statuses/public_timeline.json?count=3&include_entities=true</li>
	<li>twitter search http://search.twitter.com/search.json?q=%40twitterapi</li>
	<li>https://dev.twitter.com/docs/using-search</li>
</ul>

{% highlight python %}
>>> import urllib
>>> import json
>>> f = urllib.urlopen('http://search.twitter.com/search.json?q=%40python')
>>> d = json.loads(f.read())
>>> d['results'][0]['text']
{% endhighlight %}

	{% highlight python %}
def foo():
	bar = 0
	d = {'asdf':'fdsa'}
	for k, v in d:
		print "%s" % k
	{% endhighlight %}
<details>
</details>
</section>
